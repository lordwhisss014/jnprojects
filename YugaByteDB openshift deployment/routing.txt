Creating a YugabyteDB Cluster on OpenShift
Here's how to deploy a YugabyteDB cluster on OpenShift:

Prerequisites

OpenShift cluster with admin access

oc CLI tool installed and configured
Helm 3 installed (optional, but recommended)


Deployment Steps

1. Create a Project for YugabyteDB

oc new-project yugabyte
Insert at cursor


2. Create Security Context Constraints (SCC)
YugabyteDB requires specific permissions. Create a custom SCC:

cat <<EOF | oc create -f -
apiVersion: security.openshift.io/v1
kind: SecurityContextConstraints
metadata:
  name: yugabyte-scc
allowPrivilegedContainer: false
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: MustRunAs
fsGroup:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users:
- system:serviceaccount:yugabyte:default
EOF
Insert at cursor


3. Deploy YugabyteDB Using Helm

# Add YugabyteDB Helm repository
helm repo add yugabytedb https://charts.yugabyte.com

# Update repositories
helm repo update

# Install YugabyteDB
helm install yugabyte-cluster yugabytedb/yugabyte \
  --namespace yugabyte \
  --set resource.master.requests.cpu=0.5 \
  --set resource.master.requests.memory=1Gi \
  --set resource.tserver.requests.cpu=0.5 \
  --set resource.tserver.requests.memory=1Gi \
  --set replicas.master=3 \
  --set replicas.tserver=3 \
  --set storage.master.count=1 \
  --set storage.tserver.count=1 \
  --set storage.master.size=10Gi \
  --set storage.tserver.size=10Gi \
  --set serviceEndpoints.master.type=ClusterIP \
  --set serviceEndpoints.tserver.type=ClusterIP \
  --set enableLoadBalancer=false \
  --set istioCompatibility.enabled=false
Insert at cursor


4. Create Routes for External Access

# Create route for YugabyteDB UI
oc create route edge yugabyte-ui --service=yugabyte-cluster-yugabyte-ui --port=7000

# Create route for YSQL (PostgreSQL-compatible API)
oc create route edge yugabyte-ysql --service=yugabyte-cluster-yugabyte-tserver --port=5433

# Create route for YCQL (Cassandra-compatible API)
oc create route edge yugabyte-ycql --service=yugabyte-cluster-yugabyte-tserver --port=9042
Insert at cursor


5. Verify Deployment

# Check pods
oc get pods -n yugabyte

# Get the YugabyteDB UI URL
echo "YugabyteDB UI: https://$(oc get route yugabyte-ui -o jsonpath='{.spec.host}')"
Insert at cursor


Customization Options
You can customize your deployment by adjusting the Helm chart values:

Increase/decrease replicas for high availability
Adjust CPU/memory resources based on workload
Configure storage size based on data requirements
Enable TLS for secure communications

Would you like more details about specific configuration options or troubleshooting tips?      Give feedback to improve this answer.   


        Me:
         deploy yugabyte cluster in openshift using container  


        Duo:
         
Deploying YugabyteDB Cluster on OpenShift Using Containers
Here's a step-by-step guide to deploy a YugabyteDB cluster on OpenShift using container images directly:

Prerequisites

Access to an OpenShift cluster

oc CLI tool installed and configured
Logged in to your OpenShift cluster


Deployment Steps

1. Create a Project

oc new-project yugabyte
Insert at cursor


2. Create Security Context Constraints (SCC)

cat <<EOF | oc create -f -
apiVersion: security.openshift.io/v1
kind: SecurityContextConstraints
metadata:
  name: yugabyte-scc
allowPrivilegedContainer: false
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: MustRunAs
fsGroup:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users:
- system:serviceaccount:yugabyte:default
EOF
Insert at cursor


3. Create ConfigMap for YugabyteDB Configuration

cat <<EOF | oc create -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: yugabyte-config
  namespace: yugabyte
data:
  master.conf: |
    --fs_data_dirs=/mnt/disk0
    --rpc_bind_addresses=0.0.0.0:7100
    --webserver_interface=0.0.0.0
    --replication_factor=3
  tserver.conf: |
    --fs_data_dirs=/mnt/disk0
    --rpc_bind_addresses=0.0.0.0:9100
    --webserver_interface=0.0.0.0
    --tserver_master_addrs=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100
EOF
Insert at cursor


4. Create Persistent Volume Claims

# For Master nodes
cat <<EOF | oc create -f -
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: yb-master-data
  namespace: yugabyte
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
EOF

# For TServer nodes
cat <<EOF | oc create -f -
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: yb-tserver-data
  namespace: yugabyte
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
EOF
Insert at cursor


5. Create Master Services

# Headless service for Master StatefulSet
cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-masters
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-master
spec:
  clusterIP: None
  ports:
  - name: ui
    port: 7000
  - name: rpc-port
    port: 7100
  selector:
    app: yugabyte
    component: yb-master
EOF

# Master UI Service
cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-master-ui
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-master
spec:
  ports:
  - name: ui
    port: 7000
  selector:
    app: yugabyte
    component: yb-master
EOF
Insert at cursor


6. Create TServer Services

# Headless service for TServer StatefulSet
cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-tservers
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  clusterIP: None
  ports:
  - name: ui
    port: 9000
  - name: rpc-port
    port: 9100
  - name: cassandra
    port: 9042
  - name: redis
    port: 6379
  - name: postgres
    port: 5433
  selector:
    app: yugabyte
    component: yb-tserver
EOF

# TServer UI Service
cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-tserver-ui
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  ports:
  - name: ui
    port: 9000
  selector:
    app: yugabyte
    component: yb-tserver
EOF

# YSQL Service
cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-ysql
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  ports:
  - name: postgres
    port: 5433
  selector:
    app: yugabyte
    component: yb-tserver
EOF

# YCQL Service
cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-ycql
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  ports:
  - name: cassandra
    port: 9042
  selector:
    app: yugabyte
    component: yb-tserver
EOF
Insert at cursor


7. Create Master StatefulSet

cat <<EOF | oc create -f -
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: yb-master
  namespace: yugabyte
spec:
  serviceName: yb-masters
  replicas: 3
  selector:
    matchLabels:
      app: yugabyte
      component: yb-master
  template:
    metadata:
      labels:
        app: yugabyte
        component: yb-master
    spec:
      containers:
      - name: yb-master
        image: yugabytedb/yugabyte:latest
        command:
        - "/home/yugabyte/bin/yb-master"
        - "--config=\$(MASTER_CONF)"
        - "--master_addresses=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100"
        ports:
        - containerPort: 7000
          name: ui
        - containerPort: 7100
          name: rpc-port
        env:
        - name: MASTER_CONF
          value: /etc/yugabyte/master.conf
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: config-volume
          mountPath: /etc/yugabyte
        - name: datadir
          mountPath: /mnt/disk0
        readinessProbe:
          tcpSocket:
            port: 7100
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 7100
          initialDelaySeconds: 15
          periodSeconds: 10
      volumes:
      - name: config-volume
        configMap:
          name: yugabyte-config
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
EOF
Insert at cursor


8. Create TServer StatefulSet

cat <<EOF | oc create -f -
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: yb-tserver
  namespace: yugabyte
spec:
  serviceName: yb-tservers
  replicas: 3
  selector:
    matchLabels:
      app: yugabyte
      component: yb-tserver
  template:
    metadata:
      labels:
        app: yugabyte
        component: yb-tserver
    spec:
      containers:
      - name: yb-tserver
        image: yugabytedb/yugabyte:latest
        command:
        - "/home/yugabyte/bin/yb-tserver"
        - "--config=\$(TSERVER_CONF)"
        - "--tserver_master_addrs=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100"
        ports:
        - containerPort: 9000
          name: ui
        - containerPort: 9100
          name: rpc-port
        - containerPort: 9042
          name: cassandra
        - containerPort: 6379
          name: redis
        - containerPort: 5433
          name: postgres
        env:
        - name: TSERVER_CONF
          value: /etc/yugabyte/tserver.conf
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: config-volume
          mountPath: /etc/yugabyte
        - name: datadir
          mountPath: /mnt/disk0
        readinessProbe:
          tcpSocket:
            port: 9100
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 9100
          initialDelaySeconds: 15
          periodSeconds: 10
      volumes:
      - name: config-volume
        configMap:
          name: yugabyte-config
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
EOF
Insert at cursor


9. Create Routes for External Access

# Create route for Master UI
oc create route edge yb-master-ui --service=yb-master-ui --port=7000 -n yugabyte

# Create route for TServer UI
oc create route edge yb-tserver-ui --service=yb-tserver-ui --port=9000 -n yugabyte

# Create route for YSQL (PostgreSQL)
oc create route edge yb-ysql --service=yb-ysql --port=5433 -n yugabyte

# Create route for YCQL (Cassandra)
oc create route edge yb-ycql --service=yb-ycql --port=9042 -n yugabyte
Insert at cursor


10. Verify Deployment

# Check if all pods are running
oc get pods -n yugabyte

# Get the Master UI URL
echo "YugabyteDB Master UI: https://$(oc get route yb-master-ui -o jsonpath='{.spec.host}')"

# Get the TServer UI URL
echo "YugabyteDB TServer UI: https://$(oc get route yb-tserver-ui -o jsonpath='{.spec.host}')"
Insert at cursor


Connecting to the Database

YSQL (PostgreSQL-compatible)

# Get the YSQL endpoint
YSQL_HOST=$(oc get route yb-ysql -o jsonpath='{.spec.host}' -n yugabyte)

# Connect using psql
psql -h $YSQL_HOST -p 5433 -U yugabyte -d yugabyte
Insert at cursor


YCQL (Cassandra-compatible)

# Get the YCQL endpoint
YCQL_HOST=$(oc get route yb-ycql -o jsonpath='{.spec.host}' -n yugabyte)

# Connect using cqlsh
cqlsh $YCQL_HOST 9042 -u cassandra
Insert at cursor

This deployment creates a 3-node YugabyteDB cluster with both master and tserver components, exposing all necessary services and routes for external access.      Give feedback to improve this answer.   


        Me:
         create a yugabyte cluster on openshift using docker images  


        Duo:
         
Deploying YugabyteDB Cluster on OpenShift Using Docker Images
Here's a step-by-step guide to deploy YugabyteDB on OpenShift using Docker images:

Prerequisites

Access to an OpenShift cluster

oc CLI tool installed and configured
Logged in to your OpenShift cluster


Deployment Steps

1. Create a Project

oc new-project yugabyte
Insert at cursor


2. Set Up Security Context Constraints

cat <<EOF | oc create -f -
apiVersion: security.openshift.io/v1
kind: SecurityContextConstraints
metadata:
  name: yugabyte-scc
allowPrivilegedContainer: false
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: MustRunAs
fsGroup:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users:
- system:serviceaccount:yugabyte:default
EOF
Insert at cursor


3. Create Service Account

oc create serviceaccount yugabyte -n yugabyte
oc adm policy add-scc-to-user yugabyte-scc -z yugabyte -n yugabyte
Insert at cursor


4. Deploy YugabyteDB Master Nodes

cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-masters
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-master
spec:
  clusterIP: None
  ports:
  - name: ui
    port: 7000
  - name: rpc-port
    port: 7100
  selector:
    app: yugabyte
    component: yb-master
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: yb-master
  namespace: yugabyte
spec:
  serviceName: yb-masters
  replicas: 3
  selector:
    matchLabels:
      app: yugabyte
      component: yb-master
  template:
    metadata:
      labels:
        app: yugabyte
        component: yb-master
    spec:
      serviceAccountName: yugabyte
      containers:
      - name: yb-master
        image: docker.io/yugabytedb/yugabyte:latest
        imagePullPolicy: IfNotPresent
        command:
        - "/home/yugabyte/bin/yb-master"
        - "--fs_data_dirs=/mnt/data0"
        - "--rpc_bind_addresses=0.0.0.0:7100"
        - "--webserver_interface=0.0.0.0"
        - "--master_addresses=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100"
        - "--replication_factor=3"
        ports:
        - containerPort: 7000
          name: ui
        - containerPort: 7100
          name: rpc-port
        volumeMounts:
        - name: datadir
          mountPath: /mnt/data0
        readinessProbe:
          tcpSocket:
            port: 7100
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 7100
          initialDelaySeconds: 15
          periodSeconds: 10
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 1
            memory: 2Gi
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
EOF
Insert at cursor


5. Deploy YugabyteDB TServer Nodes

cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-tservers
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  clusterIP: None
  ports:
  - name: ui
    port: 9000
  - name: rpc-port
    port: 9100
  - name: cassandra
    port: 9042
  - name: redis
    port: 6379
  - name: postgres
    port: 5433
  selector:
    app: yugabyte
    component: yb-tserver
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: yb-tserver
  namespace: yugabyte
spec:
  serviceName: yb-tservers
  replicas: 3
  selector:
    matchLabels:
      app: yugabyte
      component: yb-tserver
  template:
    metadata:
      labels:
        app: yugabyte
        component: yb-tserver
    spec:
      serviceAccountName: yugabyte
      containers:
      - name: yb-tserver
        image: docker.io/yugabytedb/yugabyte:latest
        imagePullPolicy: IfNotPresent
        command:
        - "/home/yugabyte/bin/yb-tserver"
        - "--fs_data_dirs=/mnt/data0"
        - "--rpc_bind_addresses=0.0.0.0:9100"
        - "--webserver_interface=0.0.0.0"
        - "--tserver_master_addrs=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100"
        ports:
        - containerPort: 9000
          name: ui
        - containerPort: 9100
          name: rpc-port
        - containerPort: 9042
          name: cassandra
        - containerPort: 6379
          name: redis
        - containerPort: 5433
          name: postgres
        volumeMounts:
        - name: datadir
          mountPath: /mnt/data0
        readinessProbe:
          tcpSocket:
            port: 9100
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 9100
          initialDelaySeconds: 15
          periodSeconds: 10
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 1
            memory: 2Gi
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
EOF
Insert at cursor


6. Create External Services

cat <<EOF | oc create -f -
apiVersion: v1
kind: Service
metadata:
  name: yb-master-ui
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-master
spec:
  ports:
  - name: ui
    port: 7000
    targetPort: 7000
  selector:
    app: yugabyte
    component: yb-master
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: yb-tserver-ui
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  ports:
  - name: ui
    port: 9000
    targetPort: 9000
  selector:
    app: yugabyte
    component: yb-tserver
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: yb-ysql
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  ports:
  - name: ysql
    port: 5433
    targetPort: 5433
  selector:
    app: yugabyte
    component: yb-tserver
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: yb-ycql
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  ports:
  - name: ycql
    port: 9042
    targetPort: 9042
  selector:
    app: yugabyte
    component: yb-tserver
  type: ClusterIP
EOF
Insert at cursor


7. Create Routes for External Access

# Create route for Master UI
oc create route edge yb-master-ui --service=yb-master-ui --port=7000 -n yugabyte

# Create route for TServer UI
oc create route edge yb-tserver-ui --service=yb-tserver-ui --port=9000 -n yugabyte

# Create route for YSQL (PostgreSQL)
oc create route passthrough yb-ysql --service=yb-ysql --port=5433 -n yugabyte

# Create route for YCQL (Cassandra)
oc create route passthrough yb-ycql --service=yb-ycql --port=9042 -n yugabyte
Insert at cursor


8. Verify Deployment

# Check if all pods are running
oc get pods -n yugabyte

# Wait for all pods to be in Running state
oc wait --for=condition=Ready pod/yb-master-0 pod/yb-master-1 pod/yb-master-2 pod/yb-tserver-0 pod/yb-tserver-1 pod/yb-tserver-2 -n yugabyte --timeout=300s

# Get the Master UI URL
echo "YugabyteDB Master UI: https://$(oc get route yb-master-ui -o jsonpath='{.spec.host}')"

# Get the TServer UI URL
echo "YugabyteDB TServer UI: https://$(oc get route yb-tserver-ui -o jsonpath='{.spec.host}')"

# Get YSQL endpoint
echo "YSQL endpoint: $(oc get route yb-ysql -o jsonpath='{.spec.host}'):5433"

# Get YCQL endpoint
echo "YCQL endpoint: $(oc get route yb-ycql -o jsonpath='{.spec.host}'):9042"
Insert at cursor


Connecting to the Database

YSQL (PostgreSQL-compatible)

# Default credentials: username=yugabyte, password=yugabyte
YSQL_HOST=$(oc get route yb-ysql -o jsonpath='{.spec.host}')
psql -h $YSQL_HOST -p 5433 -U yugabyte
Insert at cursor


YCQL (Cassandra-compatible)

YCQL_HOST=$(oc get route yb-ycql -o jsonpath='{.spec.host}')
cqlsh $YCQL_HOST 9042
Insert at cursor


Notes

This deployment uses the official YugabyteDB Docker image from Docker Hub
The cluster consists of 3 master nodes and 3 tserver nodes for high availability
Each node has 10GB of persistent storage
Resource requests are set to 500m CPU and 1Gi memory per node
You can adjust the resource settings and storage size based on your requirements
     
      Thank you for your feedback.
        


        Me:
         can you create a ci/cd pipeline of the deployment  


        Duo:
         
CI/CD Pipeline for YugabyteDB Deployment on OpenShift
Here's a complete CI/CD pipeline implementation using GitLab CI/CD to deploy a YugabyteDB cluster on OpenShift:

Prerequisites

GitLab repository
OpenShift cluster
Service account with appropriate permissions
OpenShift CLI (oc) installed on the CI/CD runner


Project Structure

.
├── .gitlab-ci.yml
├── manifests/
│   ├── 01-namespace.yaml
│   ├── 02-scc.yaml
│   ├── 03-service-account.yaml
│   ├── 04-master-service.yaml
│   ├── 05-master-statefulset.yaml
│   ├── 06-tserver-service.yaml
│   ├── 07-tserver-statefulset.yaml
│   ├── 08-external-services.yaml
│   └── 09-routes.yaml
└── scripts/
    ├── deploy.sh
    └── verify.sh
Insert at cursor


GitLab CI/CD Pipeline (.gitlab-ci.yml)

stages:
  - validate
  - deploy-dev
  - test-dev
  - deploy-staging
  - test-staging
  - deploy-prod
  - test-prod

variables:
  OPENSHIFT_SERVER: ${OPENSHIFT_SERVER}
  OPENSHIFT_TOKEN: ${OPENSHIFT_TOKEN}
  NAMESPACE_DEV: yugabyte-dev
  NAMESPACE_STAGING: yugabyte-staging
  NAMESPACE_PROD: yugabyte-prod

# Template for deployment jobs
.deploy_template: &deploy_definition
  image: registry.access.redhat.com/openshift4/ose-cli:latest
  before_script:
    - oc login --token=${OPENSHIFT_TOKEN} --server=${OPENSHIFT_SERVER} --insecure-skip-tls-verify
    - chmod +x ./scripts/deploy.sh
    - chmod +x ./scripts/verify.sh
    - sed -i "s/yugabyte/${NAMESPACE}/g" ./manifests/*.yaml

validate:
  stage: validate
  image: registry.access.redhat.com/openshift4/ose-cli:latest
  script:
    - for file in manifests/*.yaml; do oc apply --dry-run=client -f $file; done
  only:
    - merge_requests

deploy-dev:
  <<: *deploy_definition
  stage: deploy-dev
  variables:
    NAMESPACE: ${NAMESPACE_DEV}
  script:
    - ./scripts/deploy.sh ${NAMESPACE}
  environment:
    name: development
  only:
    - develop

test-dev:
  <<: *deploy_definition
  stage: test-dev
  variables:
    NAMESPACE: ${NAMESPACE_DEV}
  script:
    - ./scripts/verify.sh ${NAMESPACE}
  environment:
    name: development
  only:
    - develop

deploy-staging:
  <<: *deploy_definition
  stage: deploy-staging
  variables:
    NAMESPACE: ${NAMESPACE_STAGING}
  script:
    - ./scripts/deploy.sh ${NAMESPACE}
  environment:
    name: staging
  only:
    - main
  when: manual

test-staging:
  <<: *deploy_definition
  stage: test-staging
  variables:
    NAMESPACE: ${NAMESPACE_STAGING}
  script:
    - ./scripts/verify.sh ${NAMESPACE}
  environment:
    name: staging
  only:
    - main

deploy-prod:
  <<: *deploy_definition
  stage: deploy-prod
  variables:
    NAMESPACE: ${NAMESPACE_PROD}
  script:
    - ./scripts/deploy.sh ${NAMESPACE}
  environment:
    name: production
  only:
    - tags
  when: manual

test-prod:
  <<: *deploy_definition
  stage: test-prod
  variables:
    NAMESPACE: ${NAMESPACE_PROD}
  script:
    - ./scripts/verify.sh ${NAMESPACE}
  environment:
    name: production
  only:
    - tags
Insert at cursor


Deployment Script (scripts/deploy.sh)

#!/bin/bash
set -e

NAMESPACE=$1

echo "Deploying YugabyteDB to namespace: $NAMESPACE"

# Create namespace if it doesn't exist
oc get namespace $NAMESPACE || oc create namespace $NAMESPACE

# Apply all manifests in order
for file in manifests/*.yaml; do
  echo "Applying $file..."
  oc apply -f $file -n $NAMESPACE
done

# Wait for master pods to be ready
echo "Waiting for master pods to be ready..."
oc wait --for=condition=Ready pod/yb-master-0 pod/yb-master-1 pod/yb-master-2 -n $NAMESPACE --timeout=300s

# Wait for tserver pods to be ready
echo "Waiting for tserver pods to be ready..."
oc wait --for=condition=Ready pod/yb-tserver-0 pod/yb-tserver-1 pod/yb-tserver-2 -n $NAMESPACE --timeout=300s

echo "YugabyteDB deployment completed successfully!"
Insert at cursor


Verification Script (scripts/verify.sh)

#!/bin/bash
set -e

NAMESPACE=$1

echo "Verifying YugabyteDB deployment in namespace: $NAMESPACE"

# Check if all pods are running
RUNNING_PODS=$(oc get pods -n $NAMESPACE -l app=yugabyte --no-headers | grep Running | wc -l)
if [ "$RUNNING_PODS" -ne 6 ]; then
  echo "Error: Not all pods are running. Expected 6, found $RUNNING_PODS"
  exit 1
fi

# Check master UI endpoint
MASTER_UI_ROUTE=$(oc get route yb-master-ui -n $NAMESPACE -o jsonpath='{.spec.host}')
if [ -z "$MASTER_UI_ROUTE" ]; then
  echo "Error: Master UI route not found"
  exit 1
fi

# Check YSQL endpoint
YSQL_ROUTE=$(oc get route yb-ysql -n $NAMESPACE -o jsonpath='{.spec.host}')
if [ -z "$YSQL_ROUTE" ]; then
  echo "Error: YSQL route not found"
  exit 1
fi

# Test YSQL connection (requires psql client)
if command -v psql &> /dev/null; then
  echo "Testing YSQL connection..."
  PGPASSWORD=yugabyte psql -h $YSQL_ROUTE -p 5433 -U yugabyte -c "SELECT version();" -d yugabyte
fi

echo "YugabyteDB verification completed successfully!"
echo "Master UI: https://$MASTER_UI_ROUTE"
echo "YSQL endpoint: $YSQL_ROUTE:5433"
echo "YCQL endpoint: $(oc get route yb-ycql -n $NAMESPACE -o jsonpath='{.spec.host}'):9042"
Insert at cursor


Manifest Files

01-namespace.yaml

apiVersion: v1
kind: Namespace
metadata:
  name: yugabyte
Insert at cursor


02-scc.yaml

apiVersion: security.openshift.io/v1
kind: SecurityContextConstraints
metadata:
  name: yugabyte-scc
allowPrivilegedContainer: false
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: MustRunAs
fsGroup:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users:
- system:serviceaccount:yugabyte:yugabyte
Insert at cursor


03-service-account.yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: yugabyte
  namespace: yugabyte
Insert at cursor


04-master-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: yb-masters
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-master
spec:
  clusterIP: None
  ports:
  - name: ui
    port: 7000
  - name: rpc-port
    port: 7100
  selector:
    app: yugabyte
    component: yb-master
Insert at cursor


05-master-statefulset.yaml

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: yb-master
  namespace: yugabyte
spec:
  serviceName: yb-masters
  replicas: 3
  selector:
    matchLabels:
      app: yugabyte
      component: yb-master
  template:
    metadata:
      labels:
        app: yugabyte
        component: yb-master
    spec:
      serviceAccountName: yugabyte
      containers:
      - name: yb-master
        image: docker.io/yugabytedb/yugabyte:latest
        imagePullPolicy: IfNotPresent
        command:
        - "/home/yugabyte/bin/yb-master"
        - "--fs_data_dirs=/mnt/data0"
        - "--rpc_bind_addresses=0.0.0.0:7100"
        - "--webserver_interface=0.0.0.0"
        - "--master_addresses=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100"
        - "--replication_factor=3"
        ports:
        - containerPort: 7000
          name: ui
        - containerPort: 7100
          name: rpc-port
        volumeMounts:
        - name: datadir
          mountPath: /mnt/data0
        readinessProbe:
          tcpSocket:
            port: 7100
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 7100
          initialDelaySeconds: 15
          periodSeconds: 10
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 1
            memory: 2Gi
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
Insert at cursor


06-tserver-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: yb-tservers
  namespace: yugabyte
  labels:
    app: yugabyte
    component: yb-tserver
spec:
  clusterIP: None
  ports:
  - name: ui
    port: 9000
  - name: rpc-port
    port: 9100
  - name: cassandra
    port: 9042
  - name: redis
    port: 6379
  - name: postgres
    port: 5433
  selector:
    app: yugabyte
    component: yb-tserver
Insert at cursor


07-tserver-statefulset.yaml

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: yb-tserver
  namespace: yugabyte
spec:
  serviceName: yb-tservers
  replicas: 3
  selector:
    matchLabels:
      app: yugabyte
      component: yb-tserver
  template:
    metadata:
      labels:
        app: yugabyte
        component: yb-tserver
    spec:
      serviceAccountName: yugabyte
      containers:
      - name: yb-tserver
        image: docker.io/yugabytedb/yugabyte:latest
        imagePullPolicy: IfNotPresent
        command:
        - "/home/yugabyte/bin/yb-tserver"
        - "--fs_data_dirs=/mnt/data0"
        - "--rpc_bind_addresses=0.0.0.0:9100"
        - "--webserver_interface=0.0.0.0"
        - "--tserver_master_addrs=yb-master-0.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-1.yb-masters.yugabyte.svc.cluster.local:7100,yb-master-2.yb-masters.yugabyte.svc.cluster.local:7100"
        ports:
        - containerPort: 9000
          name: ui
        - containerPort: 9100
          name: rpc-port
        - containerPort: 9042
          name: cassandra
        - containerPort: 6379
          name: redis
        - containerPort: 5433
          name: postgres
        volumeMounts:
        - name: datadir
          mountPath: /mnt/data0
        readinessProbe:
          tcpSocket:
            port: 9100
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 9100
          initialDelaySeconds: 15
          periodSeconds: 10
        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 1
            memory: 2Gi
  volumeClaimTemplates:
  - metadata:
      name: datadir
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
Insert at cursor


08-external-services.yaml
  `yaml
apiVersion: v1
kind: Service
metadata:
name: yb-master-ui
namespace: yugabyte
labels:
app: yugabyte
component: yb-master
spec:
ports:

name: ui
port: 7000
targetPort: 7000
selector:
app: yugabyte
component: yb-master
type: ClusterIP


apiVersion: v1
kind: Service
metadata:
name: yb-tserver-ui
namespace: yugabyte
labels:
app: yugabyte
component: yb-tserver
spec:
ports:

name: ui
port: 9000
targetPort: 9000
selector:
app: yugabyte
component: yb-tserver
type: ClusterIP



